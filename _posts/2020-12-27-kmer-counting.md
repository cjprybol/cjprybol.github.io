---
layout: post  
---

In this post, I want to explore how to efficiently count kmers in Julia

Two out of the box solutions for counting the number of occurances of arbitrary data points are:
- [StatsBase.countmap](https://juliastats.org/StatsBase.jl/stable/counts/#StatsBase.countmap)
- [DataStructures.counter](https://juliacollections.github.io/DataStructures.jl/latest/accumulators/#Constructors-1)

They are both convenience functions for creating an in-memory dictionary mapping all of the unique values to their counts

After the kmers have been counted, I'd like to store the kmers and counts in sorted, disk-backed vectors[^1]

[^1]: [Benchmarking kmer storage implementations]({{ site.baseurl }}{% post_url 2020-12-25-ordered-dictionary-vs-sorted-vectors-for-storing-kmers %})

In order to facilitate this, I'd like to find an efficient way of counting kmers in-memory and then dumping them and their counts to a sorted memory mapped array


```julia
import Pkg
pkgs = [
    "BioSequences",
    "Random",
    "BenchmarkTools",
    "Primes",
    "Mmap",
    "DataStructures",
    "StatsBase",
]

Pkg.add(pkgs)
for pkg in pkgs
    eval(Meta.parse("import $pkg"))
end
```

    [32m[1m   Updating[22m[39m registry at `~/.julia/registries/General`


    [?25l[2K

    [32m[1m   Updating[22m[39m git-repo `https://github.com/JuliaRegistries/General.git`


    [?25h

    [32m[1m  Resolving[22m[39m package versions...
    [32m[1mNo Changes[22m[39m to `~/.julia/environments/v1.5/Project.toml`
    [32m[1mNo Changes[22m[39m to `~/.julia/environments/v1.5/Manifest.toml`



```julia
# This macro intercepts the output that @code_warntype would write to the screen
# Because this file is originally generated in a Jupyter notebook,
# we have a rich multimedia display with text coloration options
# @code_warntype uses color to emphasize areas of concern in the functions it analyzes
# that color emphasis renders in the Jupyter notebooks,
# but not the jekyll html pages generated by the notebooks.
# By capturing the output, we also strip the output of its color,
# allowing it to render more cleanly on the jekyll pages
macro capture_code_warntype(x)
    quote
        eval(:(sprint($((@macroexpand $x).args...))))
    end
end
```




    @capture_code_warntype (macro with 1 method)




```julia
K = 3
```




    3




```julia
KMER_TYPE = BioSequences.DNAMer{K}
```




    BioSequences.Mer{BioSequences.DNAAlphabet{2},3}




```julia
sequence = BioSequences.randdnaseq(Random.seed!(1), 10^2)
```




    100nt DNA Sequence:
    GGACTGATCCGAGAAATTTACGCTCTCATAAATGCACGGâ€¦TCCTCTACTTGCGGCCGGAGGTCCTGACAACAGCCGGTT




```julia
kmer = first(BioSequences.each(KMER_TYPE, sequence))
```




    Mer iteration result:
    Position: 1
    Forward: TCG
    Backward: CGA




Below, we'll define 3 different functions that will count kmers using a dictionary and then return a sorted kmer counts dictionary

This function utilizes an `OrderedDict` that preserves insertion order of the keys but can be sorted _in-place_ to give us our desired ordering


```julia
function get_kmer_counts_ordered(::Type{KMER_TYPE}, sequence) where KMER_TYPE
    canonical_kmer_counts = DataStructures.OrderedDict{KMER_TYPE, Int}()
    canonical_kmer_iterator = (BioSequences.canonical(kmer.fw) for kmer in BioSequences.each(KMER_TYPE, sequence))
    for canonical_kmer in canonical_kmer_iterator
        canonical_kmer_counts[canonical_kmer] = get(canonical_kmer_counts, canonical_kmer, 0) + 1
    end
    return sort!(canonical_kmer_counts)
end
```




    get_kmer_counts_ordered (generic function with 1 method)



This function utilizes a `SortedDict` that enforces sort order throughout the entire life-cycle of the instance


```julia
function get_kmer_counts_sorted(::Type{KMER_TYPE}, sequence) where KMER_TYPE
    canonical_kmer_counts = DataStructures.SortedDict{KMER_TYPE, Int}()
    canonical_kmer_iterator = (BioSequences.canonical(kmer.fw) for kmer in BioSequences.each(KMER_TYPE, sequence))
    for canonical_kmer in canonical_kmer_iterator
        canonical_kmer_counts[canonical_kmer] = get(canonical_kmer_counts, canonical_kmer, 0) + 1
    end
    return canonical_kmer_counts
end
```




    get_kmer_counts_sorted (generic function with 1 method)



This final option uses the `StatsBase.countmap` internal function built around a default `Dict` type that does not enforce any level of ordering or sorting.

The sorting is not in-place and the data within the `Dict` must be copied over to a `OrderedDict` before being returned


```julia
function get_kmer_counts(::Type{KMER_TYPE}, sequence) where KMER_TYPE
    canonical_kmer_counts = Dict{KMER_TYPE, Int}()
    canonical_kmer_iterator = (BioSequences.canonical(kmer.fw) for kmer in BioSequences.each(KMER_TYPE, sequence))
    StatsBase.addcounts_dict!(canonical_kmer_counts, canonical_kmer_iterator)
    return sort(canonical_kmer_counts)
end
```




    get_kmer_counts (generic function with 1 method)



The three functions all return the same output, making them equivalently correct for achieving our goal


```julia
get_kmer_counts(KMER_TYPE, sequence) ==
get_kmer_counts_sorted(KMER_TYPE, sequence) ==
get_kmer_counts_ordered(KMER_TYPE, sequence)
```




    true



And in the following three code blocks, we can assert that they are all type-stable in their return types


```julia
# @code_warntype get_kmer_counts(KMER_TYPE, sequence)
println(@capture_code_warntype @code_warntype get_kmer_counts(KMER_TYPE, sequence))
```

    Variables
      #self#::Core.Compiler.Const(get_kmer_counts, false)
      #unused#::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},5}, false)
      sequence::BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}
      #132::var"#132#133"
      canonical_kmer_counts::Dict{BioSequences.Mer{BioSequences.DNAAlphabet{2},5},Int64}
      canonical_kmer_iterator::Base.Generator{BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},5},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}},var"#132#133"}
    
    Body::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},5},Int64}
    1 â”€ %1  = Core.apply_type(Main.Dict, $(Expr(:static_parameter, 1)), Main.Int)::Core.Compiler.Const(Dict{BioSequences.Mer{BioSequences.DNAAlphabet{2},5},Int64}, false)
    â”‚         (canonical_kmer_counts = (%1)())
    â”‚         (#132 = %new(Main.:(var"#132#133")))
    â”‚   %4  = #132::Core.Compiler.Const(var"#132#133"(), false)
    â”‚   %5  = BioSequences.each::Core.Compiler.Const(BioSequences.each, false)
    â”‚   %6  = $(Expr(:static_parameter, 1))::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},5}, false)
    â”‚   %7  = (%5)(%6, sequence)::BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},5},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}
    â”‚         (canonical_kmer_iterator = Base.Generator(%4, %7))
    â”‚   %9  = StatsBase.addcounts_dict!::Core.Compiler.Const(StatsBase.addcounts_dict!, false)
    â”‚   %10 = canonical_kmer_counts::Dict{BioSequences.Mer{BioSequences.DNAAlphabet{2},5},Int64}
    â”‚         (%9)(%10, canonical_kmer_iterator)
    â”‚   %12 = Main.sort(canonical_kmer_counts)::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},5},Int64}
    â””â”€â”€       return %12
    



```julia
# @code_warntype get_kmer_counts_sorted(KMER_TYPE, sequence)
println(@capture_code_warntype @code_warntype get_kmer_counts_sorted(KMER_TYPE, sequence))
```

    Variables
      #self#::Core.Compiler.Const(get_kmer_counts_sorted, false)
      #unused#::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
      sequence::BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}
      #3::var"#3#4"
      canonical_kmer_counts::DataStructures.SortedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64,Base.Order.ForwardOrdering}
      canonical_kmer_iterator::Base.Generator{BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}},var"#3#4"}
      @_7::UNION{NOTHING, TUPLE{BIOSEQUENCES.MER{BIOSEQUENCES.DNAALPHABET{2},31},TUPLE{INT64,INT64,UINT64,UINT64}}}
      canonical_kmer::BioSequences.Mer{BioSequences.DNAAlphabet{2},31}
    
    Body::DataStructures.SortedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64,Base.Order.ForwardOrdering}
    1 â”€ %1  = DataStructures.SortedDict::Core.Compiler.Const(DataStructures.SortedDict, false)
    â”‚   %2  = $(Expr(:static_parameter, 1))::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
    â”‚   %3  = Core.apply_type(%1, %2, Main.Int)::Core.Compiler.Const(DataStructures.SortedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64,Ord} where Ord<:Base.Order.Ordering, false)
    â”‚         (canonical_kmer_counts = (%3)())
    â”‚         (#3 = %new(Main.:(var"#3#4")))
    â”‚   %6  = #3::Core.Compiler.Const(var"#3#4"(), false)
    â”‚   %7  = BioSequences.each::Core.Compiler.Const(BioSequences.each, false)
    â”‚   %8  = $(Expr(:static_parameter, 1))::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
    â”‚   %9  = (%7)(%8, sequence)::BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}
    â”‚         (canonical_kmer_iterator = Base.Generator(%6, %9))
    â”‚   %11 = canonical_kmer_iterator::Base.Generator{BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}},var"#3#4"}
    â”‚         (@_7 = Base.iterate(%11))
    â”‚   %13 = (@_7 === nothing)::Bool
    â”‚   %14 = Base.not_int(%13)::Bool
    â””â”€â”€       goto #4 if not %14
    2 â”„ %16 = @_7::Tuple{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Tuple{Int64,Int64,UInt64,UInt64}}::Tuple{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Tuple{Int64,Int64,UInt64,UInt64}}
    â”‚         (canonical_kmer = Core.getfield(%16, 1))
    â”‚   %18 = Core.getfield(%16, 2)::Tuple{Int64,Int64,UInt64,UInt64}
    â”‚   %19 = Main.get(canonical_kmer_counts, canonical_kmer, 0)::Int64
    â”‚   %20 = (%19 + 1)::Int64
    â”‚         Base.setindex!(canonical_kmer_counts, %20, canonical_kmer)
    â”‚         (@_7 = Base.iterate(%11, %18))
    â”‚   %23 = (@_7 === nothing)::Bool
    â”‚   %24 = Base.not_int(%23)::Bool
    â””â”€â”€       goto #4 if not %24
    3 â”€       goto #2
    4 â”„       return canonical_kmer_counts
    



```julia
# @code_warntype get_kmer_counts_ordered(KMER_TYPE, sequence)
println(@capture_code_warntype @code_warntype get_kmer_counts_ordered(KMER_TYPE, sequence))
```

    Variables
      #self#::Core.Compiler.Const(get_kmer_counts_ordered, false)
      #unused#::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
      sequence::BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}
      #1::var"#1#2"
      canonical_kmer_counts::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
      canonical_kmer_iterator::Base.Generator{BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}},var"#1#2"}
      @_7::UNION{NOTHING, TUPLE{BIOSEQUENCES.MER{BIOSEQUENCES.DNAALPHABET{2},31},TUPLE{INT64,INT64,UINT64,UINT64}}}
      canonical_kmer::BioSequences.Mer{BioSequences.DNAAlphabet{2},31}
    
    Body::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    1 â”€ %1  = DataStructures.OrderedDict::Core.Compiler.Const(OrderedCollections.OrderedDict, false)
    â”‚   %2  = $(Expr(:static_parameter, 1))::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
    â”‚   %3  = Core.apply_type(%1, %2, Main.Int)::Core.Compiler.Const(OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}, false)
    â”‚         (canonical_kmer_counts = (%3)())
    â”‚         (#1 = %new(Main.:(var"#1#2")))
    â”‚   %6  = #1::Core.Compiler.Const(var"#1#2"(), false)
    â”‚   %7  = BioSequences.each::Core.Compiler.Const(BioSequences.each, false)
    â”‚   %8  = $(Expr(:static_parameter, 1))::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
    â”‚   %9  = (%7)(%8, sequence)::BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}
    â”‚         (canonical_kmer_iterator = Base.Generator(%6, %9))
    â”‚   %11 = canonical_kmer_iterator::Base.Generator{BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}},var"#1#2"}
    â”‚         (@_7 = Base.iterate(%11))
    â”‚   %13 = (@_7 === nothing)::Bool
    â”‚   %14 = Base.not_int(%13)::Bool
    â””â”€â”€       goto #4 if not %14
    2 â”„ %16 = @_7::Tuple{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Tuple{Int64,Int64,UInt64,UInt64}}::Tuple{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Tuple{Int64,Int64,UInt64,UInt64}}
    â”‚         (canonical_kmer = Core.getfield(%16, 1))
    â”‚   %18 = Core.getfield(%16, 2)::Tuple{Int64,Int64,UInt64,UInt64}
    â”‚   %19 = Main.get(canonical_kmer_counts, canonical_kmer, 0)::Int64
    â”‚   %20 = (%19 + 1)::Int64
    â”‚         Base.setindex!(canonical_kmer_counts, %20, canonical_kmer)
    â”‚         (@_7 = Base.iterate(%11, %18))
    â”‚   %23 = (@_7 === nothing)::Bool
    â”‚   %24 = Base.not_int(%23)::Bool
    â””â”€â”€       goto #4 if not %24
    3 â”€       goto #2
    4 â”„ %27 = Main.sort!(canonical_kmer_counts)::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    â””â”€â”€       return %27
    


In the following series of benchmark results, we can see that the implementation using the optimized `Dict`-based methods in `StatsBase` leads to an implementation that is both faster and more memory efficient than the `SortedDict` implementation, however is has ~2x the memory usage and is a little slower than the implementation using the `OrderedDict`


```julia
BenchmarkTools.@benchmark get_kmer_counts($KMER_TYPE, $sequence)
```




    BenchmarkTools.Trial: 
      memory estimate:  61.00 KiB
      allocs estimate:  42
      --------------
      minimum time:     45.043 Î¼s (0.00% GC)
      median time:      48.998 Î¼s (0.00% GC)
      mean time:        61.067 Î¼s (15.47% GC)
      maximum time:     10.853 ms (99.29% GC)
      --------------
      samples:          10000
      evals/sample:     1



Using a sorted Dictionary via `get_kmer_counts_sorted` is the slowest and most memory intensive, but has the fewest number of total allocations made. I imagine the extra memory overhead is due to the tree-based data structure and the extra runtime due to the $$O(logN)$$ runtime mentioned in the [documentation](https://juliacollections.github.io/DataStructures.jl/stable/sorted_containers/#Sorted-Containers-1)


```julia
BenchmarkTools.@benchmark get_kmer_counts_sorted($KMER_TYPE, $sequence)
```




    BenchmarkTools.Trial: 
      memory estimate:  73.47 KiB
      allocs estimate:  28
      --------------
      minimum time:     113.296 Î¼s (0.00% GC)
      median time:      117.337 Î¼s (0.00% GC)
      mean time:        129.898 Î¼s (7.72% GC)
      maximum time:     7.498 ms (97.84% GC)
      --------------
      samples:          10000
      evals/sample:     1



Creating an `OrderedDict` and sorting it in-place after all of the data has been added appears to be fastest and least memory intensive solution


```julia
BenchmarkTools.@benchmark get_kmer_counts_ordered($KMER_TYPE, $sequence)
```




    BenchmarkTools.Trial: 
      memory estimate:  37.03 KiB
      allocs estimate:  29
      --------------
      minimum time:     41.055 Î¼s (0.00% GC)
      median time:      43.212 Î¼s (0.00% GC)
      mean time:        52.685 Î¼s (15.51% GC)
      maximum time:     11.520 ms (99.06% GC)
      --------------
      samples:          10000
      evals/sample:     1



Let's try a series of benchmarks to make sure that these patterns hold on larger datasets


```julia
function my_display(results, indent)
    for line in split(sprint(show, "text/plain", results), '\n')
        println(repeat("\t", indent) * "$line")
    end
end

for k in [17, 31]
    for s_length in [10^i for i in 3:5]
        println("k = $k")
        println("\tsequence_length = $s_length")
        KMER_TYPE = BioSequences.DNAMer{k}
        sequence = BioSequences.randdnaseq(s_length)
        println("\t\tdefault")
        default_results = BenchmarkTools.@benchmark get_kmer_counts($KMER_TYPE, $sequence)
        my_display(default_results, 3)
        println("\t\tsorted")
        sorted_results = BenchmarkTools.@benchmark get_kmer_counts_sorted($KMER_TYPE, $sequence)
        my_display(sorted_results, 3)
        println("\t\tordered")
        ordered_results = BenchmarkTools.@benchmark get_kmer_counts_ordered($KMER_TYPE, $sequence)
        my_display(ordered_results, 3)
    end
end
```

    k = 17
    	sequence_length = 1000
    		default
    			BenchmarkTools.Trial: 
    			  memory estimate:  186.72 KiB
    			  allocs estimate:  50
    			  --------------
    			  minimum time:     120.571 Î¼s (0.00% GC)
    			  median time:      147.005 Î¼s (0.00% GC)
    			  mean time:        202.911 Î¼s (16.70% GC)
    			  maximum time:     18.398 ms (99.12% GC)
    			  --------------
    			  samples:          10000
    			  evals/sample:     1
    		sorted
    			BenchmarkTools.Trial: 
    			  memory estimate:  145.73 KiB
    			  allocs estimate:  31
    			  --------------
    			  minimum time:     151.289 Î¼s (0.00% GC)
    			  median time:      191.273 Î¼s (0.00% GC)
    			  mean time:        228.298 Î¼s (7.83% GC)
    			  maximum time:     11.964 ms (97.72% GC)
    			  --------------
    			  samples:          10000
    			  evals/sample:     1
    		ordered
    			BenchmarkTools.Trial: 
    			  memory estimate:  94.41 KiB
    			  allocs estimate:  32
    			  --------------
    			  minimum time:     76.456 Î¼s (0.00% GC)
    			  median time:      90.848 Î¼s (0.00% GC)
    			  mean time:        111.345 Î¼s (11.80% GC)
    			  maximum time:     11.872 ms (99.08% GC)
    			  --------------
    			  samples:          10000
    			  evals/sample:     1
    k = 17
    	sequence_length = 10000
    		default
    			BenchmarkTools.Trial: 
    			  memory estimate:  1.23 MiB
    			  allocs estimate:  70
    			  --------------
    			  minimum time:     1.477 ms (0.00% GC)
    			  median time:      1.849 ms (0.00% GC)
    			  mean time:        2.057 ms (8.06% GC)
    			  maximum time:     18.567 ms (89.61% GC)
    			  --------------
    			  samples:          2430
    			  evals/sample:     1
    		sorted
    			BenchmarkTools.Trial: 
    			  memory estimate:  1.51 MiB
    			  allocs estimate:  42
    			  --------------
    			  minimum time:     2.140 ms (0.00% GC)
    			  median time:      2.883 ms (0.00% GC)
    			  mean time:        3.080 ms (5.27% GC)
    			  maximum time:     10.789 ms (77.71% GC)
    			  --------------
    			  samples:          1623
    			  evals/sample:     1
    		ordered
    			BenchmarkTools.Trial: 
    			  memory estimate:  897.73 KiB
    			  allocs estimate:  46
    			  --------------
    			  minimum time:     1.219 ms (0.00% GC)
    			  median time:      1.559 ms (0.00% GC)
    			  mean time:        1.732 ms (7.71% GC)
    			  maximum time:     16.693 ms (91.05% GC)
    			  --------------
    			  samples:          2886
    			  evals/sample:     1
    k = 17
    	sequence_length = 100000
    		default
    			BenchmarkTools.Trial: 
    			  memory estimate:  14.29 MiB
    			  allocs estimate:  92
    			  --------------
    			  minimum time:     21.305 ms (0.00% GC)
    			  median time:      23.596 ms (0.00% GC)
    			  mean time:        24.975 ms (6.12% GC)
    			  maximum time:     34.687 ms (25.41% GC)
    			  --------------
    			  samples:          201
    			  evals/sample:     1
    		sorted
    			BenchmarkTools.Trial: 
    			  memory estimate:  12.03 MiB
    			  allocs estimate:  52
    			  --------------
    			  minimum time:     38.534 ms (0.00% GC)
    			  median time:      43.910 ms (0.00% GC)
    			  mean time:        46.390 ms (3.71% GC)
    			  maximum time:     85.057 ms (18.67% GC)
    			  --------------
    			  samples:          108
    			  evals/sample:     1
    		ordered
    			BenchmarkTools.Trial: 
    			  memory estimate:  8.62 MiB
    			  allocs estimate:  56
    			  --------------
    			  minimum time:     17.549 ms (0.00% GC)
    			  median time:      20.054 ms (0.00% GC)
    			  mean time:        21.042 ms (4.70% GC)
    			  maximum time:     30.846 ms (27.94% GC)
    			  --------------
    			  samples:          238
    			  evals/sample:     1
    k = 31
    	sequence_length = 1000
    		default
    			BenchmarkTools.Trial: 
    			  memory estimate:  186.53 KiB
    			  allocs estimate:  50
    			  --------------
    			  minimum time:     116.812 Î¼s (0.00% GC)
    			  median time:      133.510 Î¼s (0.00% GC)
    			  mean time:        175.879 Î¼s (18.02% GC)
    			  maximum time:     16.785 ms (99.09% GC)
    			  --------------
    			  samples:          10000
    			  evals/sample:     1
    		sorted
    			BenchmarkTools.Trial: 
    			  memory estimate:  145.73 KiB
    			  allocs estimate:  31
    			  --------------
    			  minimum time:     141.342 Î¼s (0.00% GC)
    			  median time:      170.989 Î¼s (0.00% GC)
    			  mean time:        199.006 Î¼s (8.64% GC)
    			  maximum time:     11.153 ms (98.22% GC)
    			  --------------
    			  samples:          10000
    			  evals/sample:     1
    		ordered
    			BenchmarkTools.Trial: 
    			  memory estimate:  94.22 KiB
    			  allocs estimate:  32
    			  --------------
    			  minimum time:     74.746 Î¼s (0.00% GC)
    			  median time:      84.025 Î¼s (0.00% GC)
    			  mean time:        102.825 Î¼s (12.07% GC)
    			  maximum time:     11.033 ms (99.11% GC)
    			  --------------
    			  samples:          10000
    			  evals/sample:     1
    k = 31
    	sequence_length = 10000
    		default
    			BenchmarkTools.Trial: 
    			  memory estimate:  1.23 MiB
    			  allocs estimate:  70
    			  --------------
    			  minimum time:     1.575 ms (0.00% GC)
    			  median time:      1.964 ms (0.00% GC)
    			  mean time:        2.283 ms (8.06% GC)
    			  maximum time:     21.025 ms (71.60% GC)
    			  --------------
    			  samples:          2190
    			  evals/sample:     1
    		sorted
    			BenchmarkTools.Trial: 
    			  memory estimate:  1.51 MiB
    			  allocs estimate:  42
    			  --------------
    			  minimum time:     2.055 ms (0.00% GC)
    			  median time:      2.857 ms (0.00% GC)
    			  mean time:        3.182 ms (6.05% GC)
    			  maximum time:     15.317 ms (72.67% GC)
    			  --------------
    			  samples:          1571
    			  evals/sample:     1
    		ordered
    			BenchmarkTools.Trial: 
    			  memory estimate:  897.55 KiB
    			  allocs estimate:  46
    			  --------------
    			  minimum time:     1.186 ms (0.00% GC)
    			  median time:      1.508 ms (0.00% GC)
    			  mean time:        1.671 ms (7.87% GC)
    			  maximum time:     13.290 ms (87.47% GC)
    			  --------------
    			  samples:          2991
    			  evals/sample:     1
    k = 31
    	sequence_length = 100000
    		default
    			BenchmarkTools.Trial: 
    			  memory estimate:  14.29 MiB
    			  allocs estimate:  92
    			  --------------
    			  minimum time:     20.565 ms (0.00% GC)
    			  median time:      23.939 ms (0.00% GC)
    			  mean time:        25.312 ms (6.48% GC)
    			  maximum time:     38.028 ms (0.00% GC)
    			  --------------
    			  samples:          198
    			  evals/sample:     1
    		sorted
    			BenchmarkTools.Trial: 
    			  memory estimate:  12.03 MiB
    			  allocs estimate:  52
    			  --------------
    			  minimum time:     37.024 ms (0.00% GC)
    			  median time:      42.261 ms (0.00% GC)
    			  mean time:        43.901 ms (3.37% GC)
    			  maximum time:     58.835 ms (17.72% GC)
    			  --------------
    			  samples:          114
    			  evals/sample:     1
    		ordered
    			BenchmarkTools.Trial: 
    			  memory estimate:  8.62 MiB
    			  allocs estimate:  56
    			  --------------
    			  minimum time:     16.552 ms (0.00% GC)
    			  median time:      19.564 ms (0.00% GC)
    			  mean time:        20.519 ms (4.81% GC)
    			  maximum time:     36.377 ms (28.66% GC)
    			  --------------
    			  samples:          244
    			  evals/sample:     1


The `SortedDict` implementation remained the slowest implementation regardless of the data set. The cost of copying the default `Dict` continued to grow until it required substantially more memory than the `SortedDict` implementation and was no longer competitive in total runtime to the `OrderedDict` implementation

We'll evaluate one last scenario. Rather than assessing the sorted kmer counts for one sequence, we'd like to get the sorted kmer counts for a collection of sequences

In that case, there is no need to sort until the very end, potentially saving us the additional data copy penalties of the `StatsBase` optimized counting methods

Let's create two new kmer counting methods that don't sort, then wrap them with functions that integrate the counts for each sequence assessed. The integrated count dictionary will then be sorted and returned to give us our desired output.


```julia
function get_kmer_counts_ordered_no_sort(::Type{KMER_TYPE}, sequence) where KMER_TYPE
    canonical_kmer_counts = DataStructures.OrderedDict{KMER_TYPE, Int}()
    canonical_kmer_iterator = (BioSequences.canonical(kmer.fw) for kmer in BioSequences.each(KMER_TYPE, sequence))
    for canonical_kmer in canonical_kmer_iterator
        canonical_kmer_counts[canonical_kmer] = get(canonical_kmer_counts, canonical_kmer, 0) + 1
    end
    return canonical_kmer_counts
end
```




    get_kmer_counts_ordered_no_sort (generic function with 1 method)




```julia
function get_kmer_counts_no_sort(::Type{KMER_TYPE}, sequence) where KMER_TYPE
    canonical_kmer_counts = Dict{KMER_TYPE, Int}()
    canonical_kmer_iterator = (BioSequences.canonical(kmer.fw) for kmer in BioSequences.each(KMER_TYPE, sequence))
    StatsBase.addcounts_dict!(canonical_kmer_counts, canonical_kmer_iterator)
    return canonical_kmer_counts
end
```




    get_kmer_counts_no_sort (generic function with 1 method)




```julia
function default_count_merge(::Type{KMER_TYPE}, sequences) where KMER_TYPE
    joint_kmer_counts = DataStructures.OrderedDict{KMER_TYPE, Int}()
    for sequence in sequences
        sequence_kmer_counts = get_kmer_counts_no_sort(KMER_TYPE, sequence)
        merge!(+, joint_kmer_counts, sequence_kmer_counts)
    end
    sort!(joint_kmer_counts)
end
```




    default_count_merge (generic function with 1 method)




```julia
function ordered_count_merge(::Type{KMER_TYPE}, sequences) where KMER_TYPE
    joint_kmer_counts = DataStructures.OrderedDict{KMER_TYPE, Int}()
    for sequence in sequences
        sequence_kmer_counts = get_kmer_counts_ordered_no_sort(KMER_TYPE, sequence)
        merge!(+, joint_kmer_counts, sequence_kmer_counts)
    end
    sort!(joint_kmer_counts)
end
```




    ordered_count_merge (generic function with 1 method)



Here we just sanity check that the functions are all type stable


```julia
# @code_warntype get_kmer_counts_ordered_no_sort(KMER_TYPE, sequence)
println(@capture_code_warntype @code_warntype get_kmer_counts_ordered_no_sort(KMER_TYPE, sequence))
```

    Variables
      #self#::Core.Compiler.Const(get_kmer_counts_ordered_no_sort, false)
      #unused#::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
      sequence::BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}
      #263::var"#263#264"
      canonical_kmer_counts::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
      canonical_kmer_iterator::Base.Generator{BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}},var"#263#264"}
      @_7::UNION{NOTHING, TUPLE{BIOSEQUENCES.MER{BIOSEQUENCES.DNAALPHABET{2},31},TUPLE{INT64,INT64,UINT64,UINT64}}}
      canonical_kmer::BioSequences.Mer{BioSequences.DNAAlphabet{2},31}
    
    Body::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    1 â”€ %1  = DataStructures.OrderedDict::Core.Compiler.Const(OrderedCollections.OrderedDict, false)
    â”‚   %2  = $(Expr(:static_parameter, 1))::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
    â”‚   %3  = Core.apply_type(%1, %2, Main.Int)::Core.Compiler.Const(OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}, false)
    â”‚         (canonical_kmer_counts = (%3)())
    â”‚         (#263 = %new(Main.:(var"#263#264")))
    â”‚   %6  = #263::Core.Compiler.Const(var"#263#264"(), false)
    â”‚   %7  = BioSequences.each::Core.Compiler.Const(BioSequences.each, false)
    â”‚   %8  = $(Expr(:static_parameter, 1))::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
    â”‚   %9  = (%7)(%8, sequence)::BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}
    â”‚         (canonical_kmer_iterator = Base.Generator(%6, %9))
    â”‚   %11 = canonical_kmer_iterator::Base.Generator{BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}},var"#263#264"}
    â”‚         (@_7 = Base.iterate(%11))
    â”‚   %13 = (@_7 === nothing)::Bool
    â”‚   %14 = Base.not_int(%13)::Bool
    â””â”€â”€       goto #4 if not %14
    2 â”„ %16 = @_7::Tuple{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Tuple{Int64,Int64,UInt64,UInt64}}::Tuple{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Tuple{Int64,Int64,UInt64,UInt64}}
    â”‚         (canonical_kmer = Core.getfield(%16, 1))
    â”‚   %18 = Core.getfield(%16, 2)::Tuple{Int64,Int64,UInt64,UInt64}
    â”‚   %19 = Main.get(canonical_kmer_counts, canonical_kmer, 0)::Int64
    â”‚   %20 = (%19 + 1)::Int64
    â”‚         Base.setindex!(canonical_kmer_counts, %20, canonical_kmer)
    â”‚         (@_7 = Base.iterate(%11, %18))
    â”‚   %23 = (@_7 === nothing)::Bool
    â”‚   %24 = Base.not_int(%23)::Bool
    â””â”€â”€       goto #4 if not %24
    3 â”€       goto #2
    4 â”„       return canonical_kmer_counts
    



```julia
# @code_warntype get_kmer_counts_no_sort(KMER_TYPE, sequence)
println(@capture_code_warntype @code_warntype get_kmer_counts_no_sort(KMER_TYPE, sequence))
```

    Variables
      #self#::Core.Compiler.Const(get_kmer_counts_no_sort, false)
      #unused#::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
      sequence::BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}
      #265::var"#265#266"
      canonical_kmer_counts::Dict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
      canonical_kmer_iterator::Base.Generator{BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}},var"#265#266"}
    
    Body::Dict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    1 â”€ %1  = Core.apply_type(Main.Dict, $(Expr(:static_parameter, 1)), Main.Int)::Core.Compiler.Const(Dict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}, false)
    â”‚         (canonical_kmer_counts = (%1)())
    â”‚         (#265 = %new(Main.:(var"#265#266")))
    â”‚   %4  = #265::Core.Compiler.Const(var"#265#266"(), false)
    â”‚   %5  = BioSequences.each::Core.Compiler.Const(BioSequences.each, false)
    â”‚   %6  = $(Expr(:static_parameter, 1))::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
    â”‚   %7  = (%5)(%6, sequence)::BioSequences.EveryMerIterator{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}}
    â”‚         (canonical_kmer_iterator = Base.Generator(%4, %7))
    â”‚   %9  = StatsBase.addcounts_dict!::Core.Compiler.Const(StatsBase.addcounts_dict!, false)
    â”‚   %10 = canonical_kmer_counts::Dict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    â”‚         (%9)(%10, canonical_kmer_iterator)
    â””â”€â”€       return canonical_kmer_counts
    



```julia
# @code_warntype default_count_merge(KMER_TYPE, [sequence])
println(@capture_code_warntype @code_warntype default_count_merge(KMER_TYPE, [sequence]))
```

    Variables
      #self#::Core.Compiler.Const(default_count_merge, false)
      #unused#::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
      sequences::Array{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}},1}
      joint_kmer_counts::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
      @_5::UNION{NOTHING, TUPLE{BIOSEQUENCES.LONGSEQUENCE{BIOSEQUENCES.DNAALPHABET{4}},INT64}}
      sequence::BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}
      sequence_kmer_counts::Dict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    
    Body::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    1 â”€ %1  = DataStructures.OrderedDict::Core.Compiler.Const(OrderedCollections.OrderedDict, false)
    â”‚   %2  = $(Expr(:static_parameter, 1))::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
    â”‚   %3  = Core.apply_type(%1, %2, Main.Int)::Core.Compiler.Const(OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}, false)
    â”‚         (joint_kmer_counts = (%3)())
    â”‚   %5  = sequences::Array{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}},1}
    â”‚         (@_5 = Base.iterate(%5))
    â”‚   %7  = (@_5 === nothing)::Bool
    â”‚   %8  = Base.not_int(%7)::Bool
    â””â”€â”€       goto #4 if not %8
    2 â”„ %10 = @_5::Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}},Int64}::Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}},Int64}
    â”‚         (sequence = Core.getfield(%10, 1))
    â”‚   %12 = Core.getfield(%10, 2)::Int64
    â”‚         (sequence_kmer_counts = Main.get_kmer_counts_no_sort($(Expr(:static_parameter, 1)), sequence))
    â”‚         Main.merge!(Main.:+, joint_kmer_counts, sequence_kmer_counts)
    â”‚         (@_5 = Base.iterate(%5, %12))
    â”‚   %16 = (@_5 === nothing)::Bool
    â”‚   %17 = Base.not_int(%16)::Bool
    â””â”€â”€       goto #4 if not %17
    3 â”€       goto #2
    4 â”„ %20 = Main.sort!(joint_kmer_counts)::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    â””â”€â”€       return %20
    



```julia
# @code_warntype ordered_count_merge(KMER_TYPE, [sequence])
println(@capture_code_warntype @code_warntype ordered_count_merge(KMER_TYPE, [sequence]))
```

    Variables
      #self#::Core.Compiler.Const(ordered_count_merge, false)
      #unused#::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
      sequences::Array{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}},1}
      joint_kmer_counts::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
      @_5::UNION{NOTHING, TUPLE{BIOSEQUENCES.LONGSEQUENCE{BIOSEQUENCES.DNAALPHABET{4}},INT64}}
      sequence::BioSequences.LongSequence{BioSequences.DNAAlphabet{4}}
      sequence_kmer_counts::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    
    Body::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    1 â”€ %1  = DataStructures.OrderedDict::Core.Compiler.Const(OrderedCollections.OrderedDict, false)
    â”‚   %2  = $(Expr(:static_parameter, 1))::Core.Compiler.Const(BioSequences.Mer{BioSequences.DNAAlphabet{2},31}, false)
    â”‚   %3  = Core.apply_type(%1, %2, Main.Int)::Core.Compiler.Const(OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}, false)
    â”‚         (joint_kmer_counts = (%3)())
    â”‚   %5  = sequences::Array{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}},1}
    â”‚         (@_5 = Base.iterate(%5))
    â”‚   %7  = (@_5 === nothing)::Bool
    â”‚   %8  = Base.not_int(%7)::Bool
    â””â”€â”€       goto #4 if not %8
    2 â”„ %10 = @_5::Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}},Int64}::Tuple{BioSequences.LongSequence{BioSequences.DNAAlphabet{4}},Int64}
    â”‚         (sequence = Core.getfield(%10, 1))
    â”‚   %12 = Core.getfield(%10, 2)::Int64
    â”‚         (sequence_kmer_counts = Main.get_kmer_counts_ordered_no_sort($(Expr(:static_parameter, 1)), sequence))
    â”‚         Main.merge!(Main.:+, joint_kmer_counts, sequence_kmer_counts)
    â”‚         (@_5 = Base.iterate(%5, %12))
    â”‚   %16 = (@_5 === nothing)::Bool
    â”‚   %17 = Base.not_int(%16)::Bool
    â””â”€â”€       goto #4 if not %17
    3 â”€       goto #2
    4 â”„ %20 = Main.sort!(joint_kmer_counts)::OrderedCollections.OrderedDict{BioSequences.Mer{BioSequences.DNAAlphabet{2},31},Int64}
    â””â”€â”€       return %20
    


Confirm that they return the same output


```julia
default_count_merge(KMER_TYPE, [sequence]) == ordered_count_merge(KMER_TYPE, [sequence])
```




    true



In the following benchmarks, the two options appear to be rather similar.


```julia
for k in [17, 31]
    println("k = $k")
    for sequence_length in [10^i for i in 2:3]
        println("\tsequence_length = $sequence_length")
        for n_sequences in [10^i for i in 2:3]
            println("\t\t# sequences = $n_sequences")
            KMER_TYPE = BioSequences.DNAMer{k}
            sequences = collect(BioSequences.randdnaseq(sequence_length) for i in 1:n_sequences)
            println("\t\t\tdefault")
            default_results = BenchmarkTools.@benchmark default_count_merge($KMER_TYPE, $sequences)
            my_display(default_results, 4)
            println("\t\t\tordered")
            ordered_results = BenchmarkTools.@benchmark ordered_count_merge($KMER_TYPE, $sequences)
            my_display(ordered_results, 4)
        end
    end
end
```

    k = 17
    	sequence_length = 100
    		# sequences = 100
    			default
    				BenchmarkTools.Trial: 
    				  memory estimate:  1.48 MiB
    				  allocs estimate:  1046
    				  --------------
    				  minimum time:     1.360 ms (0.00% GC)
    				  median time:      1.651 ms (0.00% GC)
    				  mean time:        1.897 ms (9.87% GC)
    				  maximum time:     12.382 ms (84.79% GC)
    				  --------------
    				  samples:          2634
    				  evals/sample:     1
    			ordered
    				BenchmarkTools.Trial: 
    				  memory estimate:  1.45 MiB
    				  allocs estimate:  1946
    				  --------------
    				  minimum time:     1.450 ms (0.00% GC)
    				  median time:      1.729 ms (0.00% GC)
    				  mean time:        1.926 ms (8.62% GC)
    				  maximum time:     12.761 ms (71.43% GC)
    				  --------------
    				  samples:          2595
    				  evals/sample:     1
    		# sequences = 1000
    			default
    				BenchmarkTools.Trial: 
    				  memory estimate:  14.68 MiB
    				  allocs estimate:  10056
    				  --------------
    				  minimum time:     17.040 ms (0.00% GC)
    				  median time:      19.296 ms (0.00% GC)
    				  mean time:        21.296 ms (7.65% GC)
    				  maximum time:     35.886 ms (21.51% GC)
    				  --------------
    				  samples:          235
    				  evals/sample:     1
    			ordered
    				BenchmarkTools.Trial: 
    				  memory estimate:  14.32 MiB
    				  allocs estimate:  19056
    				  --------------
    				  minimum time:     18.790 ms (0.00% GC)
    				  median time:      20.376 ms (0.00% GC)
    				  mean time:        21.475 ms (5.52% GC)
    				  maximum time:     29.353 ms (23.72% GC)
    				  --------------
    				  samples:          233
    				  evals/sample:     1
    	sequence_length = 1000
    		# sequences = 100
    			default
    				BenchmarkTools.Trial: 
    				  memory estimate:  17.60 MiB
    				  allocs estimate:  1856
    				  --------------
    				  minimum time:     20.329 ms (0.00% GC)
    				  median time:      23.178 ms (0.00% GC)
    				  mean time:        25.211 ms (8.59% GC)
    				  maximum time:     37.442 ms (33.01% GC)
    				  --------------
    				  samples:          199
    				  evals/sample:     1
    			ordered
    				BenchmarkTools.Trial: 
    				  memory estimate:  13.94 MiB
    				  allocs estimate:  2756
    				  --------------
    				  minimum time:     21.225 ms (0.00% GC)
    				  median time:      25.472 ms (0.00% GC)
    				  mean time:        26.267 ms (5.37% GC)
    				  maximum time:     36.710 ms (23.76% GC)
    				  --------------
    				  samples:          191
    				  evals/sample:     1
    		# sequences = 1000
    			default
    				BenchmarkTools.Trial: 
    				  memory estimate:  154.01 MiB
    				  allocs estimate:  18068
    				  --------------
    				  minimum time:     333.612 ms (4.29% GC)
    				  median time:      351.295 ms (5.18% GC)
    				  mean time:        369.969 ms (9.69% GC)
    				  maximum time:     504.657 ms (30.92% GC)
    				  --------------
    				  samples:          14
    				  evals/sample:     1
    			ordered
    				BenchmarkTools.Trial: 
    				  memory estimate:  117.40 MiB
    				  allocs estimate:  27068
    				  --------------
    				  minimum time:     336.779 ms (4.26% GC)
    				  median time:      354.630 ms (3.44% GC)
    				  mean time:        372.399 ms (3.17% GC)
    				  maximum time:     523.325 ms (3.39% GC)
    				  --------------
    				  samples:          14
    				  evals/sample:     1
    k = 31
    	sequence_length = 100
    		# sequences = 100
    			default
    				BenchmarkTools.Trial: 
    				  memory estimate:  1.20 MiB
    				  allocs estimate:  1044
    				  --------------
    				  minimum time:     1.199 ms (0.00% GC)
    				  median time:      1.546 ms (0.00% GC)
    				  mean time:        1.824 ms (9.90% GC)
    				  maximum time:     16.974 ms (91.32% GC)
    				  --------------
    				  samples:          2739
    				  evals/sample:     1
    			ordered
    				BenchmarkTools.Trial: 
    				  memory estimate:  1.16 MiB
    				  allocs estimate:  1944
    				  --------------
    				  minimum time:     1.266 ms (0.00% GC)
    				  median time:      1.638 ms (0.00% GC)
    				  mean time:        1.874 ms (8.27% GC)
    				  maximum time:     13.947 ms (84.21% GC)
    				  --------------
    				  samples:          2666
    				  evals/sample:     1
    		# sequences = 1000
    			default
    				BenchmarkTools.Trial: 
    				  memory estimate:  14.36 MiB
    				  allocs estimate:  10056
    				  --------------
    				  minimum time:     16.690 ms (0.00% GC)
    				  median time:      20.675 ms (0.00% GC)
    				  mean time:        22.242 ms (7.77% GC)
    				  maximum time:     35.273 ms (24.49% GC)
    				  --------------
    				  samples:          226
    				  evals/sample:     1
    			ordered
    				BenchmarkTools.Trial: 
    				  memory estimate:  14.00 MiB
    				  allocs estimate:  19056
    				  --------------
    				  minimum time:     16.038 ms (0.00% GC)
    				  median time:      18.333 ms (0.00% GC)
    				  mean time:        19.338 ms (6.19% GC)
    				  maximum time:     26.404 ms (25.75% GC)
    				  --------------
    				  samples:          259
    				  evals/sample:     1
    	sequence_length = 1000
    		# sequences = 100
    			default
    				BenchmarkTools.Trial: 
    				  memory estimate:  17.57 MiB
    				  allocs estimate:  1856
    				  --------------
    				  minimum time:     20.083 ms (0.00% GC)
    				  median time:      23.304 ms (0.00% GC)
    				  mean time:        25.000 ms (7.47% GC)
    				  maximum time:     40.931 ms (22.10% GC)
    				  --------------
    				  samples:          200
    				  evals/sample:     1
    			ordered
    				BenchmarkTools.Trial: 
    				  memory estimate:  13.91 MiB
    				  allocs estimate:  2756
    				  --------------
    				  minimum time:     20.707 ms (0.00% GC)
    				  median time:      23.229 ms (0.00% GC)
    				  mean time:        24.651 ms (5.42% GC)
    				  maximum time:     34.531 ms (21.53% GC)
    				  --------------
    				  samples:          203
    				  evals/sample:     1
    		# sequences = 1000
    			default
    				BenchmarkTools.Trial: 
    				  memory estimate:  153.69 MiB
    				  allocs estimate:  18068
    				  --------------
    				  minimum time:     329.546 ms (5.43% GC)
    				  median time:      343.339 ms (5.36% GC)
    				  mean time:        362.502 ms (9.88% GC)
    				  maximum time:     481.036 ms (31.07% GC)
    				  --------------
    				  samples:          14
    				  evals/sample:     1
    			ordered
    				BenchmarkTools.Trial: 
    				  memory estimate:  117.08 MiB
    				  allocs estimate:  27068
    				  --------------
    				  minimum time:     334.002 ms (2.99% GC)
    				  median time:      349.717 ms (3.51% GC)
    				  mean time:        348.381 ms (3.55% GC)
    				  maximum time:     360.740 ms (3.21% GC)
    				  --------------
    				  samples:          15
    				  evals/sample:     1


The `OrderedDict` implementation uses less overall memory, but does so with more individual allocations.

I think I'll go ahead with the `OrderedDict` version of the two in the interest of memory conservation, although I don't think we could go wrong selecting either one!
